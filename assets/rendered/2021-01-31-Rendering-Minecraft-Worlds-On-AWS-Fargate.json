{
  "title": "Rendering Minecraft Worlds on AWS Fargate",
  "fileName": "2021-01-31-Rendering-Minecraft-Worlds-On-AWS-Fargate.md",
  "dateTime": "2021-01-31 13:31",
  "tags": [
    "JavaScript",
    "Integration",
    "Java",
    "AWS"
  ],
  "components": [
    {
      "type": "image",
      "description": "",
      "src": "assets/media/2021/01/chunky-fargate-sample.png"
    },
    {
      "type": "paragraph",
      "text": "This personal project is one of those rare beasts - one that has long-lasting\nusefulness beyond the initial building of it. It doesn't have to be the case to\nbe a worthwhile project, but it helps!"
    },
    {
      "type": "paragraph",
      "text": "For a long time I've been keeping an eye on a niche open source project in the\nMinecraft community called <a class=\"link\" target=\"_blank\" href=\"https://chunky.llbit.se/\">Chunky</a>. It's a Java-based\napp that loads chunks from a Minecraft world, allows you to set up a scene with\naspects such as lighting, camera, material properties, etc., and finally to\nperform ray-traced rendering of that scene. The results offer a very pretty\nview of a world that myself or a group of friends have worked hard on and gives\nan opportunity to showcase it. Here's an example of a recent world rendered from\na Christmas community server:"
    },
    {
      "type": "image",
      "description": "",
      "src": "assets/media/2021/01/chunky-fargate-village.png"
    },
    {
      "type": "header",
      "level": 2,
      "text": "Chunky"
    },
    {
      "type": "paragraph",
      "text": "After arranging a scene in Chunky, the output is a JSON file containing all the\nparameters that set up the shot including all the factors mentioned above. You\ncan run the <code>ChunkyLancher.jar</code> file with many parameters to perform\nthe same rendering from a terminal as in the Chunky GUI. The number of samples\nper pixel (iterations) and the name of the scene are the main parameters:"
    },
    {
      "type": "paragraph",
      "text": "<!-- language=\"shell\" -->\n<pre><div class=\"code-block\">\n\njava \\\n  --module-path <span class=\"string\">\"/usr/share/maven-repo/org/openjfx/javafx-controls/11/:/usr/share/maven-repo/org/openjfx/javafx-base/11/:/usr/share/maven-repo/org/openjfx/javafx-graphics/11/:/usr/share/maven-repo/org/openjfx/javafx-fxml/11/\"</span> \\\n  --add-modules=javafx.controls,javafx.base,javafx.graphics,javafx.fxml \\\n  -Dchunky.home=<span class=\"string\">\"$(pwd)\"</span> \\\n  -jar ChunkyLauncher.jar \\\n  -f \\\n  -target $TARGET_SPP \\\n  -render $SCENE_NAME\n</div></pre>"
    },
    {
      "type": "paragraph",
      "text": "This is the first step towards automation on AWS Fargate, where containerized\nDocker apps can be run on demand and cost only while they are running."
    },
    {
      "type": "paragraph",
      "text": "Onwards to Docker!"
    },
    {
      "type": "header",
      "level": 2,
      "text": "Dockerization"
    },
    {
      "type": "paragraph",
      "text": "Since Chunky can be run from a Linux terminal, it is fairly trivial to run in\nDocker - it's just a case of choosing a suitable base image, adding the required\ndependencies and then using scripts to break up the process into manageable\nchunks. The <code>Dockerfile</code> for the finished project is shown below and\nincludes all these steps:"
    },
    {
      "type": "paragraph",
      "text": "<!-- language=\"dockerfile\" -->\n<pre><div class=\"code-block\">\n<span class=\"dockerfile-keyword\">FROM</span> ubuntu:18.04\n\n<span class=\"dockerfile-keyword\">WORKDIR</span> /chunky\n\n<span class=\"comment\"># Environment variables</span>\n<span class=\"dockerfile-keyword\">ENV</span> MC_VERSION=<span class=\"string\">\"1.16.4\"</span>\n\n<span class=\"comment\"># For tzdata dependency</span>\n<span class=\"dockerfile-keyword\">ARG</span> DEBIAN_FRONTEND=noninteractive\n<span class=\"dockerfile-keyword\">ENV</span> TZ=Europe/London\n\n<span class=\"comment\"># Dependencies</span>\n<span class=\"dockerfile-keyword\">RUN</span> apt-get update && apt-get install -y --no-install-recommends \\\n  default-jdk libopenjfx-java libcontrolsfx-java jq wget unzip awscli \\\n  && rm -rf /var/lib/apt/lists/*\n\n<span class=\"comment\"># Chunky files</span>\n<span class=\"dockerfile-keyword\">COPY</span> ChunkyLauncher.jar /chunky/ChunkyLauncher.jar\n\n<span class=\"comment\"># Initialize Chunky and Minecraft textures</span>\n<span class=\"dockerfile-keyword\">RUN</span> cd /chunky\n<span class=\"dockerfile-keyword\">RUN</span> java -Dchunky.home=<span class=\"string\">\"$(pwd)\"</span> -jar ChunkyLauncher.jar --update\n<span class=\"dockerfile-keyword\">RUN</span> java -Dchunky.home=<span class=\"string\">\"$(pwd)\"</span> -jar ChunkyLauncher.jar -download-mc $MC_VERSION\n\n<span class=\"comment\"># Pipeline</span>\n<span class=\"dockerfile-keyword\">COPY</span> pipeline /chunky/pipeline\n\n<span class=\"dockerfile-keyword\">ENTRYPOINT</span> [<span class=\"string\">\"./pipeline/pipeline.sh\"</span>]\n</div></pre>"
    },
    {
      "type": "paragraph",
      "text": "With a suitable Docker image prepared, it can be pushed to AWS Elastic Container\nRegistry to be used in a Fargate task definition."
    },
    {
      "type": "header",
      "level": 2,
      "text": "S3 as a store"
    },
    {
      "type": "paragraph",
      "text": "Since Fargate tasks run in AWS, it's not suitable for them to attempt to use\nany local files on my development machine. Yet Chunky requires world files and\nscene files in order to produce a render. To manage this, the project contains\nseveral shell scripts that use the <code>aws s3</code> command from\n<code>awscli</code> to fetch previously uploaded scene and world files from\nAmazon S3."
    },
    {
      "type": "paragraph",
      "text": "To try and ensure the setup is as easy to do as possible, the user is required\nto nominate a pre-existing S3 bucket, and a fixed subdirectory is used to\nprescribe input and output file locations. It is shown in summary with some\nexample files below:"
    },
    {
      "type": "paragraph",
      "text": "<!-- language=\"none\" -->\n<pre><div class=\"code-block\">\ns3://$BUCKET/\n  - chunky-fargate/\n    - worlds/\n      - village-world.zip\n    - scenes/\n      - village-church-interior.json\n    - renders/\n      - $DATE/\n        - snapshot.png\n        - ...\n    - tasks/\n        village-all-scenes.json\n</div></pre>"
    },
    {
      "type": "paragraph",
      "text": "As can probably be inferred, <code>worlds</code> contains Minecraft world\ndirectories in a zip file, <code>scenes</code> contains scenes from Chunky GUI,\nand <code>renders</code> contains the output PNG files in a directory per date."
    },
    {
      "type": "paragraph",
      "text": "The last directory called <code>tasks</code> contains JSON files that detail\none or more scenes in relation to a world name. More on that later."
    },
    {
      "type": "header",
      "level": 2,
      "text": "Automatic rendering on world files upload"
    },
    {
      "type": "paragraph",
      "text": "As it stands, it's easy to run Chunky locally, or start a single remote Fargate\ntask to render a chosen scene on demand. But, the key reason to put all this\ninfrastructure in place is this - be able to nominate a set of scene files to be\nrendered automatically whenever a new version of an ongoing world is uploaded\nby the Minecraft server admin. This makes it trivial to have consistent scenes\nrendered showing progress of a set of builds over time, all offloaded to the\nAWS cloud."
    },
    {
      "type": "paragraph",
      "text": "The process is shown in the diagram below:"
    },
    {
      "type": "image",
      "description": "",
      "src": "assets/media/2021/01/chunky-fargate-architecture.png"
    },
    {
      "type": "header",
      "level": 2,
      "text": "Conclusion"
    },
    {
      "type": "paragraph",
      "text": "As always, check out all the source code in the\n<a class=\"link\" target=\"_blank\" href=\"https://github.com/C-D-Lewis/stack-chat\">GitHub repository</a>."
    }
  ]
}